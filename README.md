# practice_npl_2024
## Спецификация:
### Цель программы:
Написать графическое Java-приложение, которое будет визуализировать сортировки пузырьком, слиянием и вставками.
___
### Требования:
- Приложение должно предоставлять графический интерейс для ввода массива
- Приложение должно предоставлять кнопки для выбора одной из трех алгоритмов сортировок
- Приложение должно визуализировать процесс сортировки
___
### План разработки:
#### 1. Разработка интерфейса
- Создать конструктор Main
- Добавить компоненты интерфейса с помощью Swing
- Настроить компановку и размеры компанентов
#### 2. Разработка алгоритмов сортировки
- Реализовать классы визуализации для каждого алгоритма: BubbleSort, MergeSort, InsertionSort
- Добавить методы для сортировки и визуализации
#### 3. Интеграция
- Обеспечить взаимодействие между визуалом и логикой приложения
#### 4. Тестирование
- Провести тестирование корректности работы визуализации
- Провести функциональное тестирование алгоритмов сортировки
#### 5. Документирование
- Написать отчет по выполненой работе
#### 6. Сборка
- Собрать проект в JAR-файл
___
### Распределение ролей

- **Цыгулёв Станислав Викторович 2383**
  - *Разработка алгоритмов*
  - *Сборка приложения*

- **Резник Александра Вячеславовна 2383**
  - *Разработка визуала*

- **Лустенкова Диана Дмитриевна 2383**
  - *Тестирование*
___
## Теория

### Сортировка пузырьком (Bubble Sort)

- ***Принцип работы:*** Сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке. Этот процесс повторяется от начала массива до его конца, пока все элементы не окажутся на своих местах.
- ***Сложность:*** Временная сложность O(n^2), где n - количество элементов в массиве. Пространственная сложность O(1).
- ***Стабильность:*** Да, т.к. не изменяет относительный порядок равных элементов.
  
___

### Сортировка слиянием (Merge Sort)

- ***Принцип работы:*** Разделяет массив на две половины, сортирует каждую половину рекурсивно, а затем сливает отсортированные половины вместе.
- ***Сложность:*** Временная сложность O(n log n). Пространственная сложность O(n) из-за использования дополнительного массива для слияния.
- ***Стабильность:*** Да, сохраняет относительный порядок равных элементов.

___

### Сортировка вставками (Insertion Sort)\

 - ***Принцип работы:*** Для каждого элемента массива, сравнивает его с предыдущими элементами и вставляет на правильное место, сохраняя относительный порядок элементов.
- ***Сложность:*** Временная сложность O(n^2) в худшем случае, но может быть улучшена до O(n) при почти отсортированных данных. Пространственная сложность O(1).
- ***Стабильность:*** Да, сохраняет относительный порядок равных элементов.

___

### Псевдокод

- **Алгоритм сортировки пузырьком**
```
PROCEDURE BubbleSort(array)
    n = длина(array)
    currentKeyIndex = n - 1
    currentCompareIndex = 0
    
    WHILE currentKeyIndex > 0
        IF currentCompareIndex < currentKeyIndex
            IF array[currentCompareIndex] > array[currentCompareIndex + 1]
                SWAP(array[currentCompareIndex], array[currentCompareIndex + 1])
            END IF
            currentCompareIndex = currentCompareIndex + 1
        ELSE
            currentKeyIndex = currentKeyIndex - 1
            currentCompareIndex = 0
        END IF
    END WHILE
END PROCEDURE
```

- **Алгоритм сортировки слиянием**
```
Merge(A, B):
i = 1; j = 1; k = 1;
a_(m+1) = ∞; b_{n+1} = ∞
while (k <= m+n) do:
    if (a_i < b_j) then
        c_k = a_i; i++;
    else
        c_k = b_j; j++;
    k++;
return C = {c_1, c_2, …, c_(m+n)}

MergeSort(X, n)
if (n == 1) return X
middle = n/2 (round down)
A = {x_1, x_2, …, x_middle}
B = {x_(middle+1), x_{middle+2), …, x_n}
As = MergeSort(A, middle)
Bs = MergeSort(B, n - middle)
return Merge(As, Bs)
```

- **Алгоритм сортировки вставками**

```
PROCEDURE MergeSort(array)
    n = длина(array)
    tempArray = массив_размером(n)
    currentSize = 1
    
    WHILE currentSize < n
        leftStart = 0
        
        WHILE leftStart < n - 1
            mid = минимальное(leftStart + currentSize - 1, n - 1)
            rightEnd = минимальное(leftStart + 2*currentSize - 1, n - 1)
            
            // Процедура слияния
            КОПИРОВАТЬ array[leftStart..rightEnd] В tempArray[leftStart..rightEnd]
            i = leftStart
            j = mid + 1
            k = leftStart
            
            WHILE i <= mid И j <= rightEnd
                IF tempArray[i] <= tempArray[j]
                    array[k] = tempArray[i]
                    i = i + 1
                ELSE
                    array[k] = tempArray[j]
                    j = j + 1
                END IF
                k = k + 1
            END WHILE
            
            WHILE i <= mid
                array[k] = tempArray[i]
                k = k + 1
                i = i + 1
            END WHILE
            
            leftStart = leftStart + 2*currentSize
        END WHILE
        
        currentSize = currentSize * 2
    END WHILE
END PROCEDURE
```
